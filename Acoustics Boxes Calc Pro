app/src/main/assets/Hertz Acoustics Boxes Calc Pro.html 
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Audio Lab Pro v8 - An√°lisis Espectral</title>
    
    <!-- 1. Estilos (Tailwind CSS) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React y ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #18181b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
        body { background-color: #09090b; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;

        // --- CONSTANTES ---
        const SPEED_OF_SOUND_M_S = 343; // Velocidad del sonido en m/s
        const PR_SIZES = ['4','5','6','6x9','8','10','12','13.5','15','18','21']; // Tama√±os de Radiador Pasivo en pulgadas

        // --- ICONOS SVG ---
        const Icons = {
            Speaker: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="16" height="20" x="4" y="2" rx="2"/><circle cx="12" cy="14" r="4"/><line x1="12" x2="12.01" y1="6" y2="6"/></svg>,
            Box: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z"/><path d="m3.3 7 8.7 5 8.7-5"/><path d="M12 22V12"/></svg>,
            Activity: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>,
            Anchor: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="5" r="3"/><line x1="12" x2="12" y1="22" y2="8"/><path d="M5 12H2a10 10 0 0 0 20 0h-3"/></svg>,
            BarChart2: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/></svg>,
            Pointer: () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.239"/><path d="M16 19.998l-3.5-3.5-2 2"/></svg>
        };

        // --- DATA DE MATERIALES (CORREGIDA CON NOMBRES EN ESPA√ëOL) ---
        const materialDefinitions = {
            'MDF': { thick: 1.8, Fr: 40, name: 'MDF' },
            'Plywood': { thick: 1.5, Fr: 55, name: 'Contrachapado' },
            'Cedro,Wood': { thick: 2.0, Fr: 76, name: 'Madera Cedro' },
            'Roble,Wood': { thick: 2.0, Fr: 65, name: 'Madera Roble' },
            'Aluminum': { thick: 0.5, Fr: 120, name: 'Aluminio' },
            'Plastic': { thick: 0.8, Fr: 80, name: 'Pl√°stico' }, 
            'Fiberglass': { thick: 0.6, Fr: 95, name: 'Fibra de Vidrio' },
            'Chipboard': { thick: 1.6, Fr: 30, name: 'Aglomerado' },

        };

        const getSafeNumber = (value, minValue = 1) => Math.max(minValue, Number(value) || minValue);
        
        // Mapeo de claves internas a etiquetas en espa√±ol
        const boxLabels = {
            'h': 'Alto',
            'w': 'Ancho',
            'd': 'Fondo'
        };

        // --- MOTOR DE C√ÅLCULO DE RESPUESTA ---
        const calculateFullResponse = (sub, box, ventType, slotPort, roundPort, passive, netVol, Fb) => {
            const points = [];
            const START_FREQ = 20;
            const END_FREQ = 250;
            const STEP = 1.0;
            
            // Par√°metros seguros
            const Fs = getSafeNumber(sub.fs, 1);
            const Qts = getSafeNumber(sub.qts, 0.1);
            const Vas = getSafeNumber(sub.vas, 1);
            const Vb = getSafeNumber(netVol, 1);
            const thick = getSafeNumber(box.thick, 0.1);
            const count = getSafeNumber(sub.count, 1);
            const safeFb = getSafeNumber(Fb, 1);
            
            // Dimensiones internas
            const internalH = getSafeNumber(box.h - 2 * thick, 1);
            const internalW = getSafeNumber(box.w - 2 * thick, 1);
            const internalD = getSafeNumber(box.d - 2 * thick, 1);

            const alpha = (Vas * count) / Vb;

            // 1. Modos de Caja Axiales
            const modes = [
                { dim: internalD / 100 }, { dim: internalW / 100 }, { dim: internalH / 100 }
            ].map(m => {
                const F1 = SPEED_OF_SOUND_M_S / (2 * m.dim);
                // Se simula 1er y 2do arm√≥nico axial
                return [ { F: F1, factor: 0.6 }, { F: F1 * 2, factor: 0.3 } ];
            }).flat().filter(m => m.F < END_FREQ);

            // 2. Resonancias de Tubo (Pipe Resonances)
            let pipeResonances = [];
            let Leff = 0;

            if (ventType === 'slot') {
                const area = (getSafeNumber(slotPort.h)*getSafeNumber(slotPort.w))/10000;
                Leff = (getSafeNumber(slotPort.l)/100) + (0.732 * Math.sqrt(area/Math.PI)); 
            } else if (ventType === 'round') {
                Leff = (getSafeNumber(roundPort.l)/100) + (0.8 * (getSafeNumber(roundPort.d)/100));
            }

            if (Leff > 0 && ventType !== 'passive' && ventType !== 'sealed') {
                const Fp1 = SPEED_OF_SOUND_M_S / (2 * Leff); 
                if (Fp1 > safeFb * 1.5 && Fp1 < END_FREQ) pipeResonances.push({ F: Fp1, factor: 0.7 });
                if (Fp1 * 3 < END_FREQ) pipeResonances.push({ F: Fp1 * 3, factor: 0.4 });
                if (Fp1 * 5 < END_FREQ) pipeResonances.push({ F: Fp1 * 5, factor: 0.2 });
            }

            // 3. Generar Puntos de Respuesta
            for (let f = START_FREQ; f <= END_FREQ; f += STEP) {
                let mag_base = 0;

                if (ventType === 'sealed') {
                    // Respuesta Caja Sellada (2do Orden) - F√≥rmula de Butterwort/Bessel
                    const Qtc = Qts * Math.sqrt(1 + alpha);
                    const ratio = f / safeFb; // f / Fc
                    const ratioSq = ratio * ratio;
                    const denom = Math.sqrt(Math.pow(1 - ratioSq, 2) + Math.pow(ratio / Qtc, 2));
                    mag_base = 20 * Math.log10(ratioSq / denom);
                } else {
                    // Respuesta Vented/Passive (Aproximaci√≥n 4to Orden)
                    if (f > 0 && safeFb > 0 && Fs > 0) {
                        if (f < safeFb * 0.9) {
                            mag_base = -12 * Math.log10(safeFb / f);
                        } else if (f > safeFb * 1.5) {
                            const term1 = 1 + (f / Fs)**4 * (1/alpha)**2;
                            mag_base = 20 * Math.log10(1 / Math.sqrt(term1)); 
                        } else {
                            // Pico de sinton√≠a
                            const peakFactor = (Qts * Math.sqrt(alpha)) - 0.3; 
                            const damping = Math.abs(f - safeFb) / (safeFb * 0.5); 
                            mag_base = Math.max(-10, peakFactor * 5 * Math.exp(-damping * damping));
                        }
                    }
                }

                // 4. Sumar Efectos de Resonancia
                let mode_effect = 0;
                modes.forEach(m => {
                    const delta = Math.abs(f - m.F) / m.F;
                    // Simulaci√≥n de pico resonante (Q alto)
                    if (delta < 0.1) mode_effect += 5 * m.factor * (1 / (1 + 64 * delta * delta));
                });
                pipeResonances.forEach(p => {
                    const delta = Math.abs(f - p.F) / p.F;
                    // Simulaci√≥n de pico de tubo (Q medio)
                    if (delta < 0.05) mode_effect += 3 * p.factor * (1 / (1 + 25 * delta * delta));
                });

                // 5. Recorte y guardado
                points.push({ f, mag: Math.max(-24, Math.min(6, mag_base + mode_effect)) });
            }

            return points;
        };

        // --- COMPONENTE PRINCIPAL ---
        function App() {
            // Inicializamos el material con una clave v√°lida
            const initialMaterialKey = 'MDF';

            // ESTADOS DE ENTRADA
            const [sub, setSub] = useState({ size: '12', disp: 4.0, fs: 32, qts: 0.5, vas: 60, count: 1 });
            const [box, setBox] = useState({ 
                h: 80, 
                w: 40, 
                d: 40, 
                thick: materialDefinitions[initialMaterialKey].thick, 
                material: initialMaterialKey, 
                panelResonance: materialDefinitions[initialMaterialKey].Fr 
            });
            const [ventType, setVentType] = useState('slot'); 
            const [viewMode, setViewMode] = useState('graph');
            
            const [slotPort, setSlotPort] = useState({ h: 8, w: 40, l: 30 });
            const [roundPort, setRoundPort] = useState({ d: 10.16, l: 30, q: 1 });
            const [passive, setPassive] = useState({ size: '15', fs: 22, vas: 120, mms: 200, addedMass: 0, disp: 2.5, count: 1 });
            
            // ESTADOS DE SALIDA
            const [results, setResults] = useState(null);
            const [hoverPoint, setHoverPoint] = useState(null);

            // Manejadores de entrada
            const handleMaterialChange = (newMaterialKey) => {
                const definition = materialDefinitions[newMaterialKey];
                if (definition) {
                    setBox(prev => ({ 
                        ...prev, 
                        material: newMaterialKey, 
                        thick: definition.thick, 
                        panelResonance: definition.Fr 
                    }));
                }
            };

            const handleInputChange = (e, stateKey, minVal, setter) => {
                setter(prev => ({...prev, [stateKey]: getSafeNumber(e.target.value, minVal)}));
            };

            // --- FUNCI√ìN DE C√ÅLCULO PRINCIPAL ---
            const calculate = useCallback(() => {
                const safeThick = getSafeNumber(box.thick, 0.1);
                const h_int = getSafeNumber(box.h, 10) - (2 * safeThick);
                const w_int = getSafeNumber(box.w, 10) - (2 * safeThick);
                const d_int = getSafeNumber(box.d, 10) - (2 * safeThick);
                
                if (h_int <= 0 || w_int <= 0 || d_int <= 0) {
                    setResults({ netVol: 0, tuning: 0, qtc: 0, profile: "DIMENSIONES INV√ÅLIDAS", fullResponse: [] });
                    return;
                }
                const vol_int_total = (h_int * w_int * d_int) / 1000; // Volumen interno total en Litros

                let system_disp = 0; // Desplazamiento del puerto/PR en Litros
                let Fb = 0;          // Frecuencia de Sinton√≠a (Fb) o Frecuencia de Corte (Fc)
                let calculatedQtc = 0; // Factor Q total para sellado
                let fs_passive_modified = passive.fs;

                if (ventType === 'sealed') {
                    // C√ÅLCULO CAJ√ìN SELLADO
                    const subDisp = getSafeNumber(sub.disp, 0) * getSafeNumber(sub.count, 1);
                    const net_temp = vol_int_total - subDisp;
                    if (net_temp > 0) {
                        const totalVas = getSafeNumber(sub.vas, 1) * getSafeNumber(sub.count, 1);
                        const alpha = totalVas / net_temp;
                        Fb = getSafeNumber(sub.fs, 1) * Math.sqrt(1 + alpha); // Fc (Frecuencia de corte)
                        calculatedQtc = getSafeNumber(sub.qts, 0.1) * Math.sqrt(1 + alpha); // Qtc (Factor de Calidad Total)
                    }
                } else if (ventType === 'slot') {
                    const safeH = getSafeNumber(slotPort.h, 1);
                    const safeW = getSafeNumber(slotPort.w, 1);
                    const safeL = getSafeNumber(slotPort.l, 1);
                    system_disp = ((safeH + safeThick) * (safeW + safeThick) * safeL) / 1000;
                    
                    const subDisp = getSafeNumber(sub.disp, 0) * getSafeNumber(sub.count, 1);
                    const net_m3 = (vol_int_total - system_disp - subDisp) / 1000;
                    const area_m2 = (safeH * safeW) / 10000;
                    const eff_len_m = (safeL / 100) + (0.732 * Math.sqrt(area_m2 / Math.PI)); // Correcci√≥n de extremos
                    
                    if (net_m3 > 0) Fb = (SPEED_OF_SOUND_M_S / (2 * Math.PI)) * Math.sqrt(area_m2 / (net_m3 * eff_len_m));

                } else if (ventType === 'round') {
                    const r = getSafeNumber(roundPort.d, 1) / 2;
                    const L = getSafeNumber(roundPort.l, 1);
                    const Q = getSafeNumber(roundPort.q, 1);
                    system_disp = ((Math.PI * Math.pow(r + 0.3, 2) * L) / 1000) * Q; // Desplazamiento aproximado

                    const subDisp = getSafeNumber(sub.disp, 0) * getSafeNumber(sub.count, 1);
                    const net_m3 = (vol_int_total - system_disp - subDisp) / 1000;
                    const area_m2 = (Math.PI * r * r * Q) / 10000;
                    const eff_len_m = (L / 100) + (0.8 * (2*r/100));

                    if (net_m3 > 0) Fb = (SPEED_OF_SOUND_M_S / (2 * Math.PI)) * Math.sqrt(area_m2 / (net_m3 * eff_len_m));
                } else {
                    // C√ÅLCULO RADIADOR PASIVO
                    system_disp = getSafeNumber(passive.disp, 0) * getSafeNumber(passive.count, 1);
                    const subDisp = getSafeNumber(sub.disp, 0) * getSafeNumber(sub.count, 1);
                    const net_temp = vol_int_total - system_disp - subDisp;
                    const mms = getSafeNumber(passive.mms, 1);
                    const added = getSafeNumber(passive.addedMass, 0);
                    
                    // Fs modificado por masa agregada
                    fs_passive_modified = getSafeNumber(passive.fs, 1) * Math.sqrt(mms / (mms + added));
                    
                    const vas_pr = getSafeNumber(passive.vas, 1) * getSafeNumber(passive.count, 1);

                    if (net_temp > 0) Fb = fs_passive_modified * Math.sqrt((vas_pr / net_temp) + 1);
                }

                const net_vol = vol_int_total - system_disp - (getSafeNumber(sub.disp, 0) * getSafeNumber(sub.count, 1));
                
                // Determinaci√≥n del perfil sonoro
                let soundProfile = "";
                if (ventType === 'sealed') {
                    if (calculatedQtc <= 0.55) soundProfile = "Muy Amortiguado (Transitorio)";
                    else if (calculatedQtc <= 0.75) soundProfile = "Plana (Audi√≥filo / Hi-Fi)";
                    else if (calculatedQtc <= 1.1) soundProfile = "Punch / Pop / Rock";
                    else soundProfile = "Retumb√≥n / Boom";
                } else {
                     const ratio = Fb / getSafeNumber(sub.fs, 1);
                     if (ratio < 0.75) soundProfile = "Sub-Bajo Profundo";
                     else if (ratio <= 1.05) soundProfile = "Musical / Equilibrada";
                     else soundProfile = "SPL / Golpe Seco";
                }

                // Generar datos de la curva de respuesta
                const fullResponseData = calculateFullResponse(sub, box, ventType, slotPort, roundPort, passive, net_vol, Fb);

                setResults({ 
                    netVol: net_vol, 
                    tuning: Fb || 0, 
                    qtc: calculatedQtc,
                    prFsNew: fs_passive_modified, 
                    profile: soundProfile,
                    fullResponse: fullResponseData 
                });
            }, [box, sub, slotPort, roundPort, passive, ventType]);

            useEffect(() => { calculate(); }, [calculate]);

            // L√≥gica para la Trazabilidad del Cursor en el gr√°fico
            const GRAPH_W = 100;
            const START_FREQ = 20;
            const END_FREQ = 250;
            const FREQ_RANGE = END_FREQ - START_FREQ;

            const handleMouseMove = (e) => {
                if (!results?.fullResponse) return;
                const svgRect = e.currentTarget.getBoundingClientRect();
                const normalizedX = ((e.clientX - svgRect.left) / svgRect.width) * GRAPH_W;
                const fCursor = START_FREQ + (normalizedX / GRAPH_W) * FREQ_RANGE;

                let closest = null, minDiff = Infinity;
                results.fullResponse.forEach(p => {
                    const diff = Math.abs(p.f - fCursor);
                    if (diff < minDiff) { minDiff = diff; closest = p; }
                });

                if (minDiff > 5) { setHoverPoint(null); return; }

                setHoverPoint({
                    f: closest.f,
                    mag: closest.mag,
                    x: closest ? ((closest.f - START_FREQ) / FREQ_RANGE) * GRAPH_W : normalizedX,
                    y: closest ? 60 - ((closest.mag + 24) / 30) * 60 : 0
                });
            };

            const graphPoints = useMemo(() => {
                if (!results?.fullResponse) return "";
                return results.fullResponse.map(p => {
                    const x = ((p.f - START_FREQ) / FREQ_RANGE) * GRAPH_W;
                    const y = 60 - ((p.mag + 24) / 30) * 60; // 60 unidades de alto para -24dB a +6dB
                    return `${x},${y}`;
                }).join(" ");
            }, [results]);

            // Alineaci√≥n SPL: Monitoreo de Resonancia del Panel vs Frecuencia de Sinton√≠a
            const getAlignment = () => {
                if (!results) return { text: "...", color: "text-zinc-500", icon: "‚Ä¢", delta: 0 };
                const fb = results.tuning;
                const fr = getSafeNumber(box.panelResonance, 1);
                const delta = Math.abs(fb - fr);
                if (delta <= 3) return { text: "Alineaci√≥n M√°xima (SPL)", color: "text-red-500", icon: "üî•", delta };
                if (delta <= 7) return { text: "Alineaci√≥n Buena", color: "text-yellow-500", icon: "‚ö†Ô∏è", delta };
                if (delta <= 15) return { text: "Alineaci√≥n Moderada", color: "text-cyan-500", icon: "üîä", delta };
                return { text: "Alineaci√≥n Neutra", color: "text-green-500", icon: "‚úÖ", delta };
            };
            const align = getAlignment();

            if (!results) return <div className="min-h-screen bg-black text-white flex items-center justify-center">Cargando Audio Lab...</div>;

            return (
                <div className="min-h-screen bg-zinc-950 text-white font-sans flex justify-center p-2 sm:p-4 selection:bg-cyan-500">
                <div className="w-full max-w-lg bg-black rounded-3xl border border-zinc-800 shadow-2xl overflow-hidden flex flex-col h-[90vh] sm:h-auto">
                    
                    {/* HEADER */}
                    <div cl="bg-cyan-950 p-4 shrink-0 flex justify-between items-center shadow-lg border-b border-cyan-900/50 relative overflow-hidden">
                    <div cl
